"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[644],{3362:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-1/chapter-2/nodes-architecture","title":"ROS 2 Nodes and Architecture","description":"This chapter explores the fundamental building blocks of ROS 2 systems - nodes and their architecture. Understanding nodes is crucial for creating distributed robotic applications.","source":"@site/docs/module-1/chapter-2/nodes-architecture.md","sourceDirName":"module-1/chapter-2","slug":"/module-1/chapter-2/nodes-architecture","permalink":"/ai-robo-learning/docs/module-1/chapter-2/nodes-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/madnan-github/ai-robo-learning/docs/module-1/chapter-2/nodes-architecture.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"ROS 2 Nodes and Architecture"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Physical AI & Humanoid Robotics","permalink":"/ai-robo-learning/docs/module-1/chapter-1/introduction"},"next":{"title":"Topics and Message Passing","permalink":"/ai-robo-learning/docs/module-1/chapter-3/topics-message-passing"}}');var r=i(4848),t=i(8453);const l={sidebar_position:2,title:"ROS 2 Nodes and Architecture"},o="ROS 2 Nodes and Architecture",a={},d=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Understanding ROS 2 Nodes",id:"understanding-ros-2-nodes",level:2},{value:"Node Architecture",id:"node-architecture",level:3},{value:"Node Naming and Namespaces",id:"node-naming-and-namespaces",level:3},{value:"Creating Nodes with rclpy",id:"creating-nodes-with-rclpy",level:2},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"Hands-on Lab: Creating Your First Node",id:"hands-on-lab-creating-your-first-node",level:2},{value:"Step 1: Create the Node File",id:"step-1-create-the-node-file",level:3},{value:"Step 2: Make the File Executable",id:"step-2-make-the-file-executable",level:3},{value:"Step 3: Run the Node",id:"step-3-run-the-node",level:3},{value:"Node Communication Patterns",id:"node-communication-patterns",level:2},{value:"Publisher-Subscriber Pattern",id:"publisher-subscriber-pattern",level:3},{value:"Service-Client Pattern",id:"service-client-pattern",level:3},{value:"Action Pattern",id:"action-pattern",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"ros-2-nodes-and-architecture",children:"ROS 2 Nodes and Architecture"})}),"\n",(0,r.jsx)(n.p,{children:"This chapter explores the fundamental building blocks of ROS 2 systems - nodes and their architecture. Understanding nodes is crucial for creating distributed robotic applications."}),"\n",(0,r.jsx)(n.h2,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,r.jsx)(n.p,{children:"In this chapter, you'll explore:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The concept of ROS 2 nodes and their role"}),"\n",(0,r.jsx)(n.li,{children:"Node architecture and communication patterns"}),"\n",(0,r.jsx)(n.li,{children:"Creating and managing nodes using rclpy"}),"\n",(0,r.jsx)(n.li,{children:"Node lifecycle and best practices"}),"\n",(0,r.jsx)(n.li,{children:"Debugging node communication issues"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Completion of Module 1, Chapter 1"}),"\n",(0,r.jsx)(n.li,{children:"Basic Python programming knowledge"}),"\n",(0,r.jsx)(n.li,{children:"ROS 2 Humble installed on your system"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"understanding-ros-2-nodes",children:"Understanding ROS 2 Nodes"}),"\n",(0,r.jsx)(n.p,{children:"A ROS 2 node is an executable process that uses ROS 2 client libraries to communicate with other nodes. Nodes are the fundamental building blocks of ROS 2 applications and can:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Publish messages to topics"}),"\n",(0,r.jsx)(n.li,{children:"Subscribe to topics to receive messages"}),"\n",(0,r.jsx)(n.li,{children:"Provide services"}),"\n",(0,r.jsx)(n.li,{children:"Call services"}),"\n",(0,r.jsx)(n.li,{children:"Create action servers and clients"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"node-architecture",children:"Node Architecture"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 follows a distributed architecture where nodes can run on the same machine or across a network. The ROS 2 middleware (RMW - ROS Middleware) handles communication between nodes using DDS (Data Distribution Service) implementations."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[Node A] -----\x3e [DDS/RMW] -----\x3e [Node B]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"node-naming-and-namespaces",children:"Node Naming and Namespaces"}),"\n",(0,r.jsx)(n.p,{children:"Nodes must have unique names within a ROS 2 domain. Namespaces provide a way to organize nodes hierarchically, similar to file system paths."}),"\n",(0,r.jsx)(n.h2,{id:"creating-nodes-with-rclpy",children:"Creating Nodes with rclpy"}),"\n",(0,r.jsx)(n.p,{children:"Let's create our first ROS 2 node using Python:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalNode(Node):\n\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.get_logger().info('Minimal node initialized')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    minimal_node = MinimalNode()\n\n    # Spin the node so it continues to run\n    rclpy.spin(minimal_node)\n\n    # Clean up\n    minimal_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 nodes follow a specific lifecycle:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Unconfigured"}),"\n",(0,r.jsx)(n.li,{children:"Inactive"}),"\n",(0,r.jsx)(n.li,{children:"Active"}),"\n",(0,r.jsx)(n.li,{children:"Finalized"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This lifecycle allows for better resource management and coordination between nodes."}),"\n",(0,r.jsx)(n.h2,{id:"hands-on-lab-creating-your-first-node",children:"Hands-on Lab: Creating Your First Node"}),"\n",(0,r.jsx)(n.p,{children:"In this lab, you'll create a simple node that logs messages at regular intervals."}),"\n",(0,r.jsx)(n.h3,{id:"step-1-create-the-node-file",children:"Step 1: Create the Node File"}),"\n",(0,r.jsxs)(n.p,{children:["Create a file called ",(0,r.jsx)(n.code,{children:"timed_node.py"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass TimedNode(Node):\n\n    def __init__(self):\n        super().__init__('timed_node')\n        self.counter = 0\n        self.timer = self.create_timer(1.0, self.timer_callback)  # 1 second timer\n        self.get_logger().info('Timed node initialized')\n\n    def timer_callback(self):\n        self.counter += 1\n        self.get_logger().info(f'Timer called {self.counter} times')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    timed_node = TimedNode()\n\n    try:\n        rclpy.spin(timed_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        timed_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-make-the-file-executable",children:"Step 2: Make the File Executable"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"chmod +x timed_node.py\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-run-the-node",children:"Step 3: Run the Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"source /opt/ros/humble/setup.bash\npython3 timed_node.py\n"})}),"\n",(0,r.jsx)(n.p,{children:"You should see log messages appearing every second."}),"\n",(0,r.jsx)(n.h2,{id:"node-communication-patterns",children:"Node Communication Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"publisher-subscriber-pattern",children:"Publisher-Subscriber Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Nodes communicate through topics using the publisher-subscriber pattern:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Publishers send messages to topics"}),"\n",(0,r.jsx)(n.li,{children:"Subscribers receive messages from topics"}),"\n",(0,r.jsx)(n.li,{children:"Multiple publishers and subscribers can exist for the same topic"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"service-client-pattern",children:"Service-Client Pattern"}),"\n",(0,r.jsx)(n.p,{children:"For request-response communication:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Services provide functionality"}),"\n",(0,r.jsx)(n.li,{children:"Clients request specific operations"}),"\n",(0,r.jsx)(n.li,{children:"Communication is synchronous"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"action-pattern",children:"Action Pattern"}),"\n",(0,r.jsx)(n.p,{children:"For long-running operations with feedback:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Actions have goals, feedback, and results"}),"\n",(0,r.jsx)(n.li,{children:"Suitable for tasks like navigation or manipulation"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node Design"}),": Keep nodes focused on a single responsibility"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),": Implement proper exception handling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource Management"}),": Clean up resources properly in destructors"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logging"}),": Use appropriate log levels (info, warn, error, debug)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameter Handling"}),": Use parameters for configuration"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"After completing this chapter, you'll be ready to dive deeper into ROS 2 communication patterns by learning about topics and message passing in Chapter 3."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);