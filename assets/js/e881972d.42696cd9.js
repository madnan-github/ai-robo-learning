"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[263],{5626:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"module-3/chapter-5/path-planning-humanoids","title":"Path Planning for Humanoids","description":"This chapter focuses on path planning specifically designed for bipedal humanoid robots, addressing the unique challenges of walking locomotion, balance, and stability that differentiate humanoid navigation from wheeled robots.","source":"@site/docs/module-3/chapter-5/path-planning-humanoids.md","sourceDirName":"module-3/chapter-5","slug":"/module-3/chapter-5/path-planning-humanoids","permalink":"/ai-robo-learning/docs/module-3/chapter-5/path-planning-humanoids","draft":false,"unlisted":false,"editUrl":"https://github.com/madnan-github/ai-robo-learning/docs/module-3/chapter-5/path-planning-humanoids.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Path Planning for Humanoids"},"sidebar":"tutorialSidebar","previous":{"title":"Navigation with Nav2","permalink":"/ai-robo-learning/docs/module-3/chapter-4/navigation-nav2"},"next":{"title":"Perception Systems","permalink":"/ai-robo-learning/docs/module-3/chapter-6/perception-systems"}}');var a=t(4848),o=t(8453);const r={sidebar_position:5,title:"Path Planning for Humanoids"},i="Path Planning for Humanoids",l={},p=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Understanding Humanoid Locomotion Constraints",id:"understanding-humanoid-locomotion-constraints",level:2},{value:"Differences from Wheeled Robots",id:"differences-from-wheeled-robots",level:3},{value:"Key Constraints",id:"key-constraints",level:3},{value:"Footstep Planning Algorithms",id:"footstep-planning-algorithms",level:2},{value:"Basic Footstep Planner",id:"basic-footstep-planner",level:3},{value:"Advanced Footstep Planning with Stability",id:"advanced-footstep-planning-with-stability",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"ZMP-Based Walking Pattern",id:"zmp-based-walking-pattern",level:3},{value:"Terrain Adaptability for Humanoids",id:"terrain-adaptability-for-humanoids",level:2},{value:"Terrain Classification and Adaptation",id:"terrain-classification-and-adaptation",level:3},{value:"Balance-Aware Path Planning",id:"balance-aware-path-planning",level:2},{value:"Center of Mass Optimization",id:"center-of-mass-optimization",level:3},{value:"Hands-on Lab: Complete Humanoid Navigation System",id:"hands-on-lab-complete-humanoid-navigation-system",level:2},{value:"Step 1: Create the Main Navigation Node",id:"step-1-create-the-main-navigation-node",level:3},{value:"Step 2: Test the Navigation System",id:"step-2-test-the-navigation-system",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"Adaptive Parameter Tuning",id:"adaptive-parameter-tuning",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"path-planning-for-humanoids",children:"Path Planning for Humanoids"})}),"\n",(0,a.jsx)(n.p,{children:"This chapter focuses on path planning specifically designed for bipedal humanoid robots, addressing the unique challenges of walking locomotion, balance, and stability that differentiate humanoid navigation from wheeled robots."}),"\n",(0,a.jsx)(n.h2,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,a.jsx)(n.p,{children:"In this chapter, you'll explore:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Bipedal locomotion constraints in path planning"}),"\n",(0,a.jsx)(n.li,{children:"Footstep planning algorithms"}),"\n",(0,a.jsx)(n.li,{children:"Balance-aware path planning"}),"\n",(0,a.jsx)(n.li,{children:"Walking pattern generation"}),"\n",(0,a.jsx)(n.li,{children:"Terrain adaptability for humanoids"}),"\n",(0,a.jsx)(n.li,{children:"Stability optimization techniques"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Completion of Module 1-3, Chapters 1-4"}),"\n",(0,a.jsx)(n.li,{children:"Understanding of basic path planning algorithms"}),"\n",(0,a.jsx)(n.li,{children:"Knowledge of humanoid robot kinematics"}),"\n",(0,a.jsx)(n.li,{children:"Experience with ROS 2 navigation systems"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"understanding-humanoid-locomotion-constraints",children:"Understanding Humanoid Locomotion Constraints"}),"\n",(0,a.jsx)(n.h3,{id:"differences-from-wheeled-robots",children:"Differences from Wheeled Robots"}),"\n",(0,a.jsx)(n.p,{children:"Humanoid robots face unique challenges in navigation:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Bipedal Gait"}),": Requires alternating foot placement"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Balance Requirements"}),": Must maintain center of mass within support polygon"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Limited Turning"}),": Cannot rotate in place like wheeled robots"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Step Height Limits"}),": Cannot step over large obstacles"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Terrain Sensitivity"}),": Requires stable footholds"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"key-constraints",children:"Key Constraints"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Step Length"}),": Maximum distance between consecutive footsteps"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Step Width"}),": Lateral distance between left and right footsteps"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Step Height"}),": Maximum obstacle height that can be stepped over"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Turning Radius"}),": Minimum radius for turning maneuvers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Stability Margin"}),": Required safety margin from support polygon edges"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"footstep-planning-algorithms",children:"Footstep Planning Algorithms"}),"\n",(0,a.jsx)(n.h3,{id:"basic-footstep-planner",children:"Basic Footstep Planner"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom visualization_msgs.msg import Marker, MarkerArray\nfrom nav_msgs.msg import Path\nimport numpy as np\nimport math\nfrom collections import deque\n\nclass FootstepPlanner(Node):\n    def __init__(self):\n        super().__init__(\'footstep_planner\')\n\n        # Subscribe to navigation goal\n        self.goal_sub = self.create_subscription(\n            PoseStamped,\n            \'/goal_pose\',\n            self.goal_callback,\n            10\n        )\n\n        # Publishers\n        self.footstep_pub = self.create_publisher(Path, \'/footsteps\', 10)\n        self.marker_pub = self.create_publisher(MarkerArray, \'/footstep_markers\', 10)\n\n        # Robot-specific parameters\n        self.step_length_max = 0.3  # meters\n        self.step_width_max = 0.2  # meters\n        self.turn_radius_min = 0.5  # meters\n        self.step_height_max = 0.1  # meters\n\n        # Current robot state\n        self.current_pose = None\n        self.current_goal = None\n        self.footstep_sequence = []\n\n        self.get_logger().info(\'Footstep Planner initialized\')\n\n    def goal_callback(self, msg):\n        """Process navigation goal and plan footsteps"""\n        self.current_goal = msg\n        self.plan_footsteps()\n\n    def plan_footsteps(self):\n        """Plan sequence of footsteps from current position to goal"""\n        if self.current_pose is None or self.current_goal is None:\n            return\n\n        # Calculate distance and direction to goal\n        dx = self.current_goal.pose.position.x - self.current_pose.position.x\n        dy = self.current_goal.pose.position.y - self.current_pose.position.y\n        distance = math.sqrt(dx**2 + dy**2)\n        angle = math.atan2(dy, dx)\n\n        # Generate footsteps\n        footsteps = self.generate_footsteps(\n            self.current_pose.position.x,\n            self.current_pose.position.y,\n            self.current_pose.orientation,\n            self.current_goal.pose.position.x,\n            self.current_goal.pose.position.y,\n            angle\n        )\n\n        if footsteps:\n            # Create Path message\n            path_msg = Path()\n            path_msg.header.stamp = self.get_clock().now().to_msg()\n            path_msg.header.frame_id = "map"\n\n            for step in footsteps:\n                pose_stamped = PoseStamped()\n                pose_stamped.header.frame_id = "map"\n                pose_stamped.pose.position.x = step[0]\n                pose_stamped.pose.position.y = step[1]\n                pose_stamped.pose.position.z = 0.0\n                pose_stamped.pose.orientation.w = 1.0\n                path_msg.poses.append(pose_stamped)\n\n            # Publish footsteps\n            self.footstep_pub.publish(path_msg)\n            self.publish_footstep_markers(path_msg)\n\n            self.get_logger().info(f\'Planned {len(footsteps)} footsteps to goal\')\n\n    def generate_footsteps(self, start_x, start_y, start_orientation, goal_x, goal_y, goal_angle):\n        """Generate sequence of footsteps using simple algorithm"""\n        footsteps = []\n\n        # Current position and orientation\n        current_x, current_y = start_x, start_y\n        current_angle = math.atan2(goal_y - current_y, goal_x - current_x)\n\n        # Calculate number of steps needed\n        dx = goal_x - current_x\n        dy = goal_y - current_y\n        distance = math.sqrt(dx**2 + dy**2)\n        num_steps = int(distance / self.step_length_max) + 1\n\n        # Generate footsteps\n        for i in range(num_steps):\n            # Calculate next step position\n            step_ratio = (i + 1) / num_steps\n            next_x = start_x + dx * step_ratio\n            next_y = start_y + dy * step_ratio\n\n            # Alternate between left and right foot\n            if i % 2 == 0:  # Left foot\n                next_x += self.step_width_max / 2 * math.sin(current_angle)\n                next_y -= self.step_width_max / 2 * math.cos(current_angle)\n            else:  # Right foot\n                next_x -= self.step_width_max / 2 * math.sin(current_angle)\n                next_y += self.step_width_max / 2 * math.cos(current_angle)\n\n            footsteps.append((next_x, next_y))\n\n        return footsteps\n\n    def publish_footstep_markers(self, path_msg):\n        """Publish visualization markers for footsteps"""\n        marker_array = MarkerArray()\n\n        # Create markers for each footstep\n        for i, pose_stamped in enumerate(path_msg.poses):\n            # Footstep marker\n            footstep_marker = Marker()\n            footstep_marker.header = path_msg.header\n            footstep_marker.ns = "footsteps"\n            footstep_marker.id = i\n            footstep_marker.type = Marker.CYLINDER\n            footstep_marker.action = Marker.ADD\n\n            footstep_marker.pose = pose_stamped.pose\n            footstep_marker.scale.x = 0.1  # Diameter\n            footstep_marker.scale.y = 0.1\n            footstep_marker.scale.z = 0.05  # Height\n\n            # Color based on foot (left=blue, right=red)\n            if i % 2 == 0:  # Left foot\n                footstep_marker.color.r = 0.0\n                footstep_marker.color.g = 0.0\n                footstep_marker.color.b = 1.0\n            else:  # Right foot\n                footstep_marker.color.r = 1.0\n                footstep_marker.color.g = 0.0\n                footstep_marker.color.b = 0.0\n            footstep_marker.color.a = 0.7\n\n            marker_array.markers.append(footstep_marker)\n\n        self.marker_pub.publish(marker_array)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = FootstepPlanner()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"advanced-footstep-planning-with-stability",children:"Advanced Footstep Planning with Stability"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom nav_msgs.msg import OccupancyGrid, Path\nfrom visualization_msgs.msg import MarkerArray\nimport numpy as np\nimport math\nfrom scipy.spatial import KDTree\n\nclass StableFootstepPlanner(Node):\n    def __init__(self):\n        super().__init__(\'stable_footstep_planner\')\n\n        # Subscribe to costmap and goal\n        self.costmap_sub = self.create_subscription(\n            OccupancyGrid,\n            \'/global_costmap/costmap\',\n            self.costmap_callback,\n            10\n        )\n\n        self.goal_sub = self.create_subscription(\n            PoseStamped,\n            \'/goal_pose\',\n            self.goal_callback,\n            10\n        )\n\n        # Publishers\n        self.footstep_pub = self.create_publisher(Path, \'/stable_footsteps\', 10)\n        self.marker_pub = self.create_publisher(MarkerArray, \'/stable_footstep_markers\', 10)\n\n        # Costmap data\n        self.costmap = None\n        self.map_resolution = 0.05\n        self.map_origin = [0, 0]\n\n        # Robot parameters\n        self.step_length_max = 0.3  # meters\n        self.step_width_max = 0.2\n        self.foot_size = 0.15  # meters (foot length/width)\n        self.support_polygon_radius = 0.1  # meters (for stability margin)\n\n        # Current state\n        self.current_pose = None\n        self.current_goal = None\n\n        self.get_logger().info(\'Stable Footstep Planner initialized\')\n\n    def costmap_callback(self, msg):\n        """Process incoming costmap"""\n        self.costmap = np.array(msg.data).reshape(msg.info.height, msg.info.width)\n        self.map_resolution = msg.info.resolution\n        self.map_origin = [msg.info.origin.position.x, msg.info.origin.position.y]\n\n    def goal_callback(self, msg):\n        """Process navigation goal"""\n        self.current_goal = msg\n        self.plan_stable_footsteps()\n\n    def plan_stable_footsteps(self):\n        """Plan footsteps considering stability and terrain"""\n        if self.costmap is None or self.current_goal is None:\n            return\n\n        # Convert goal to map coordinates\n        goal_map_x = int((self.current_goal.pose.position.x - self.map_origin[0]) / self.map_resolution)\n        goal_map_y = int((self.current_goal.pose.position.y - self.map_origin[1]) / self.map_resolution)\n\n        # Convert current position to map coordinates\n        if self.current_pose:\n            current_map_x = int((self.current_pose.position.x - self.map_origin[0]) / self.map_resolution)\n            current_map_y = int((self.current_pose.position.y - self.map_origin[1]) / self.map_resolution)\n        else:\n            current_map_x, current_map_y = self.costmap.shape[1] // 2, self.costmap.shape[0] // 2\n\n        # Plan footsteps using A* with stability constraints\n        footsteps = self.plan_stable_path(current_map_x, current_map_y, goal_map_x, goal_map_y)\n\n        if footsteps:\n            # Convert map coordinates back to world coordinates\n            world_footsteps = []\n            for x, y in footsteps:\n                world_x = x * self.map_resolution + self.map_origin[0]\n                world_y = y * self.map_resolution + self.map_origin[1]\n                world_footsteps.append((world_x, world_y))\n\n            # Create and publish path\n            path_msg = self.create_path_message(world_footsteps)\n            self.footstep_pub.publish(path_msg)\n            self.publish_footstep_markers(path_msg)\n\n            self.get_logger().info(f\'Planned {len(footsteps)} stable footsteps\')\n\n    def plan_stable_path(self, start_x, start_y, goal_x, goal_y):\n        """Plan path with stability constraints"""\n        # Use A* algorithm but with stability-aware cost function\n        from queue import PriorityQueue\n\n        open_set = PriorityQueue()\n        open_set.put((0, (start_x, start_y)))\n\n        came_from = {}\n        g_score = {(start_x, start_y): 0}\n        f_score = {(start_x, start_y): self.stability_heuristic(start_x, start_y, goal_x, goal_y)}\n\n        while not open_set.empty():\n            current = open_set.get()[1]\n\n            if current == (goal_x, goal_y):\n                # Reconstruct path\n                path = [current]\n                while current in came_from:\n                    current = came_from[current]\n                    path.append(current)\n                path.reverse()\n                return path\n\n            # Get valid neighbors considering step constraints\n            for neighbor in self.get_stable_neighbors(current[0], current[1]):\n                if neighbor[0] < 0 or neighbor[0] >= self.costmap.shape[1] or \\\n                   neighbor[1] < 0 or neighbor[1] >= self.costmap.shape[0]:\n                    continue\n\n                # Check if neighbor is traversable\n                if self.costmap[neighbor[1], neighbor[0]] > 50:  # Obstacle\n                    continue\n\n                # Check stability of step\n                if not self.is_stable_step(current[0], current[1], neighbor[0], neighbor[1]):\n                    continue\n\n                tentative_g_score = g_score[current] + self.stability_cost(current, neighbor)\n\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.stability_heuristic(neighbor[0], neighbor[1], goal_x, goal_y)\n                    open_set.put((f_score[neighbor], neighbor))\n\n        return None  # No path found\n\n    def get_stable_neighbors(self, x, y):\n        """Get neighbors within step constraints"""\n        neighbors = []\n\n        # Generate potential step positions within constraints\n        for dx in range(-int(self.step_length_max / self.map_resolution),\n                        int(self.step_length_max / self.map_resolution) + 1):\n            for dy in range(-int(self.step_width_max / self.map_resolution),\n                            int(self.step_width_max / self.map_resolution) + 1):\n                if dx == 0 and dy == 0:\n                    continue\n\n                # Check step length constraint\n                step_distance = math.sqrt(dx**2 + dy**2) * self.map_resolution\n                if step_distance <= self.step_length_max:\n                    neighbors.append((x + dx, y + dy))\n\n        return neighbors\n\n    def is_stable_step(self, from_x, from_y, to_x, to_y):\n        """Check if a step maintains stability"""\n        # Check if the step is within robot\'s capabilities\n        step_dx = (to_x - from_x) * self.map_resolution\n        step_dy = (to_y - from_y) * self.map_resolution\n        step_distance = math.sqrt(step_dx**2 + step_dy**2)\n\n        if step_distance > self.step_length_max:\n            return False\n\n        # Check if the target position is stable (not on an obstacle)\n        if self.costmap[to_y, to_x] > 50:\n            return False\n\n        # Additional stability checks could go here\n        # For example, checking terrain roughness, slope, etc.\n\n        return True\n\n    def stability_cost(self, pos1, pos2):\n        """Calculate cost considering stability factors"""\n        # Base cost is distance\n        dx = (pos2[0] - pos1[0]) * self.map_resolution\n        dy = (pos2[1] - pos1[1]) * self.map_resolution\n        base_cost = math.sqrt(dx**2 + dy**2)\n\n        # Add penalty for unstable terrain\n        terrain_cost = self.costmap[pos2[1], pos2[0]] / 100.0  # Normalize costmap value\n\n        # Add penalty for sharp turns (affects balance)\n        if len(self.get_stable_neighbors(pos1[0], pos1[1])) > 4:  # If there are many options, prefer straight paths\n            direction_cost = abs(math.atan2(dy, dx)) * 0.1\n        else:\n            direction_cost = 0\n\n        return base_cost + terrain_cost + direction_cost\n\n    def stability_heuristic(self, x1, y1, x2, y2):\n        """Heuristic function considering stability"""\n        dx = (x2 - x1) * self.map_resolution\n        dy = (y2 - y1) * self.map_resolution\n        distance = math.sqrt(dx**2 + dy**2)\n\n        # Simple Euclidean distance heuristic\n        return distance\n\n    def create_path_message(self, footsteps):\n        """Create Path message from footsteps"""\n        path_msg = Path()\n        path_msg.header.stamp = self.get_clock().now().to_msg()\n        path_msg.header.frame_id = "map"\n\n        for x, y in footsteps:\n            pose_stamped = PoseStamped()\n            pose_stamped.header.frame_id = "map"\n            pose_stamped.pose.position.x = x\n            pose_stamped.pose.position.y = y\n            pose_stamped.pose.position.z = 0.0\n            pose_stamped.pose.orientation.w = 1.0\n            path_msg.poses.append(pose_stamped)\n\n        return path_msg\n\n    def publish_footstep_markers(self, path_msg):\n        """Publish visualization markers for footsteps"""\n        marker_array = MarkerArray()\n\n        for i, pose_stamped in enumerate(path_msg.poses):\n            # Footstep marker\n            footstep_marker = self.create_footstep_marker(pose_stamped, i)\n            marker_array.markers.append(footstep_marker)\n\n            # Support polygon marker\n            support_marker = self.create_support_polygon_marker(pose_stamped, i + len(path_msg.poses))\n            marker_array.markers.append(support_marker)\n\n        self.marker_pub.publish(marker_array)\n\n    def create_footstep_marker(self, pose_stamped, id_num):\n        """Create a marker for a single footstep"""\n        marker = Marker()\n        marker.header = pose_stamped.header\n        marker.ns = "footsteps"\n        marker.id = id_num\n        marker.type = Marker.CYLINDER\n        marker.action = Marker.ADD\n\n        marker.pose = pose_stamped.pose\n        marker.scale.x = self.foot_size\n        marker.scale.y = self.foot_size\n        marker.scale.z = 0.02\n\n        # Color based on foot (left=blue, right=red)\n        if id_num % 2 == 0:  # Left foot\n            marker.color.r = 0.0\n            marker.color.g = 0.0\n            marker.color.b = 1.0\n        else:  # Right foot\n            marker.color.r = 1.0\n            marker.color.g = 0.0\n            marker.color.b = 0.0\n        marker.color.a = 0.8\n\n        return marker\n\n    def create_support_polygon_marker(self, pose_stamped, id_num):\n        """Create a marker for the support polygon"""\n        marker = Marker()\n        marker.header = pose_stamped.header\n        marker.ns = "support_polygons"\n        marker.id = id_num\n        marker.type = Marker.SPHERE\n        marker.action = Marker.ADD\n\n        marker.pose = pose_stamped.pose\n        marker.scale.x = self.support_polygon_radius * 2\n        marker.scale.y = self.support_polygon_radius * 2\n        marker.scale.z = 0.01\n\n        marker.color.r = 0.0\n        marker.color.g = 1.0\n        marker.color.b = 0.0\n        marker.color.a = 0.3\n\n        return marker\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = StableFootstepPlanner()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,a.jsx)(n.h3,{id:"zmp-based-walking-pattern",children:"ZMP-Based Walking Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float32MultiArray\nfrom geometry_msgs.msg import Twist, Pose\nimport numpy as np\nimport math\n\nclass ZMPWalkingPatternGenerator(Node):\n    def __init__(self):\n        super().__init__(\'zmp_walking_pattern_generator\')\n\n        # Publisher for walking commands\n        self.walking_cmd_pub = self.create_publisher(Float32MultiArray, \'/walking_commands\', 10)\n\n        # Robot parameters for ZMP (Zero Moment Point) calculation\n        self.robot_height = 0.8  # meters (height of CoM)\n        self.gravity = 9.81  # m/s^2\n        self.step_time = 1.0  # seconds per step\n        self.com_height = 0.8  # center of mass height\n\n        # Walking parameters\n        self.step_length = 0.3  # meters\n        self.step_width = 0.2  # meters\n        self.turn_angle = 0.0  # radians\n\n        # Current walking state\n        self.is_walking = False\n        self.current_step = 0\n        self.total_steps = 0\n\n        self.get_logger().info(\'ZMP Walking Pattern Generator initialized\')\n\n    def generate_walking_pattern(self, step_length, step_width, num_steps, turn_angle=0.0):\n        """Generate ZMP-based walking pattern"""\n        # Calculate ZMP trajectory for stable walking\n        omega = math.sqrt(self.gravity / self.com_height)  # Natural frequency\n\n        # Time parameters\n        dt = 0.01  # 100 Hz control rate\n        step_duration = self.step_time\n        double_support_duration = 0.2  # 20% of step time in double support\n        single_support_duration = step_duration - double_support_duration\n\n        # Generate complete walking pattern\n        walking_pattern = []\n\n        for step_idx in range(num_steps):\n            # Determine foot positions for this step\n            if step_idx % 2 == 0:  # Left foot step\n                foot_x = (step_idx // 2) * step_length\n                foot_y = step_width / 2\n            else:  # Right foot step\n                foot_x = ((step_idx - 1) // 2) * step_length\n                foot_y = -step_width / 2\n\n            # Generate ZMP trajectory for this step\n            step_pattern = self.generate_step_zmp_trajectory(\n                foot_x, foot_y, omega, dt, single_support_duration, double_support_duration\n            )\n\n            walking_pattern.extend(step_pattern)\n\n        # Publish walking pattern\n        self.publish_walking_commands(walking_pattern)\n\n    def generate_step_zmp_trajectory(self, foot_x, foot_y, omega, dt, single_supp_dur, double_supp_dur):\n        """Generate ZMP trajectory for a single step"""\n        trajectory = []\n\n        # Single support phase (swing foot)\n        single_support_steps = int(single_supp_dur / dt)\n        for i in range(single_support_steps):\n            t = i * dt\n            # ZMP trajectory during single support (approaches foot position)\n            zmp_x = foot_x * (1 - math.exp(-omega * t)) / (1 - math.exp(-omega * single_supp_dur))\n            zmp_y = foot_y\n            trajectory.append([zmp_x, zmp_y, t])\n\n        # Double support phase (both feet on ground)\n        double_support_steps = int(double_supp_dur / dt)\n        for i in range(double_support_steps):\n            t = single_supp_dur + i * dt\n            # ZMP stays at foot position during double support\n            zmp_x = foot_x\n            zmp_y = foot_y\n            trajectory.append([zmp_x, zmp_y, t])\n\n        return trajectory\n\n    def publish_walking_commands(self, walking_pattern):\n        """Publish walking commands to robot controller"""\n        for zmp_data in walking_pattern:\n            cmd_msg = Float32MultiArray()\n            cmd_msg.data = zmp_data  # [zmp_x, zmp_y, time]\n            self.walking_cmd_pub.publish(cmd_msg)\n\n    def start_walking(self, linear_vel, angular_vel):\n        """Start walking with specified velocities"""\n        if linear_vel == 0 and angular_vel == 0:\n            self.stop_walking()\n            return\n\n        # Calculate number of steps based on desired velocity\n        step_frequency = 1.0 / self.step_time  # steps per second\n        desired_speed = abs(linear_vel)\n\n        if desired_speed > 0:\n            self.step_length = desired_speed * self.step_time\n            num_steps = int(10)  # Plan 10 steps ahead (example)\n        else:\n            num_steps = 0\n\n        self.turn_angle = angular_vel * self.step_time  # Turn per step\n\n        if num_steps > 0:\n            self.generate_walking_pattern(\n                self.step_length,\n                self.step_width,\n                num_steps,\n                self.turn_angle\n            )\n            self.is_walking = True\n            self.get_logger().info(f\'Starting walk: {num_steps} steps, speed {desired_speed:.2f} m/s\')\n\n    def stop_walking(self):\n        """Stop walking motion"""\n        self.is_walking = False\n        # Send stop command to robot\n        stop_msg = Float32MultiArray()\n        stop_msg.data = [0.0, 0.0, 0.0]  # [zmp_x, zmp_y, time] - stop position\n        self.walking_cmd_pub.publish(stop_msg)\n        self.get_logger().info(\'Walking stopped\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ZMPWalkingPatternGenerator()\n\n    try:\n        # Example: Start walking forward\n        node.start_walking(linear_vel=0.3, angular_vel=0.0)\n\n        # Run for a while then stop\n        import time\n        time.sleep(5)\n        node.stop_walking()\n\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"terrain-adaptability-for-humanoids",children:"Terrain Adaptability for Humanoids"}),"\n",(0,a.jsx)(n.h3,{id:"terrain-classification-and-adaptation",children:"Terrain Classification and Adaptation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import PointCloud2, Image\nfrom geometry_msgs.msg import PointStamped\nfrom std_msgs.msg import String\nimport numpy as np\nimport cv2\nfrom sklearn.cluster import KMeans\nfrom scipy.spatial import distance\nimport math\n\nclass TerrainAdaptationNode(Node):\n    def __init__(self):\n        super().__init__('terrain_adaptation_node')\n\n        # Subscribe to sensor data\n        self.pointcloud_sub = self.create_subscription(\n            PointCloud2,\n            '/points2',\n            self.pointcloud_callback,\n            10\n        )\n\n        self.camera_sub = self.create_subscription(\n            Image,\n            '/camera/image_raw',\n            self.camera_callback,\n            10\n        )\n\n        # Publishers\n        self.terrain_class_pub = self.create_publisher(String, '/terrain_classification', 10)\n        self.footstep_params_pub = self.create_publisher(String, '/footstep_parameters', 10)\n\n        # Terrain classification parameters\n        self.terrain_types = {\n            'flat': {'roughness_threshold': 0.01, 'slope_threshold': 0.1, 'step_height': 0.1},\n            'uneven': {'roughness_threshold': 0.05, 'slope_threshold': 0.3, 'step_height': 0.05},\n            'stairs': {'roughness_threshold': 0.02, 'slope_threshold': 0.5, 'step_height': 0.15},\n            'obstacle': {'roughness_threshold': 0.1, 'slope_threshold': 0.2, 'step_height': 0.2}\n        }\n\n        # Current terrain classification\n        self.current_terrain = 'flat'\n        self.terrain_confidence = 1.0\n\n        self.get_logger().info('Terrain Adaptation Node initialized')\n\n    def pointcloud_callback(self, msg):\n        \"\"\"Process point cloud data for terrain analysis\"\"\"\n        try:\n            # Convert PointCloud2 to numpy array (simplified - in real system, use pcl library)\n            # For this example, we'll simulate the conversion\n            points_3d = self.convert_pointcloud_to_array(msg)\n\n            if points_3d is not None and len(points_3d) > 10:\n                # Analyze terrain properties\n                roughness = self.calculate_surface_roughness(points_3d)\n                slope = self.calculate_surface_slope(points_3d)\n\n                # Classify terrain\n                terrain_type, confidence = self.classify_terrain(roughness, slope)\n\n                if terrain_type != self.current_terrain:\n                    self.current_terrain = terrain_type\n                    self.terrain_confidence = confidence\n\n                    # Publish terrain classification\n                    terrain_msg = String()\n                    terrain_msg.data = f\"{terrain_type}:{confidence:.2f}\"\n                    self.terrain_class_pub.publish(terrain_msg)\n\n                    # Publish adapted footstep parameters\n                    self.publish_adapted_parameters(terrain_type)\n\n                    self.get_logger().info(f'Terrain classified as {terrain_type} (confidence: {confidence:.2f})')\n\n        except Exception as e:\n            self.get_logger().error(f'Error processing point cloud: {str(e)}')\n\n    def camera_callback(self, msg):\n        \"\"\"Process camera data for terrain texture analysis\"\"\"\n        try:\n            # Convert ROS Image to OpenCV\n            from cv_bridge import CvBridge\n            bridge = CvBridge()\n            cv_image = bridge.imgmsg_to_cv2(msg, \"bgr8\")\n\n            # Analyze texture and color for terrain classification\n            texture_features = self.extract_texture_features(cv_image)\n\n            # This could be used to complement point cloud analysis\n            # For now, we'll just log the analysis\n            self.get_logger().info(f'Image texture analysis completed')\n\n        except Exception as e:\n            self.get_logger().error(f'Error processing camera image: {str(e)}')\n\n    def convert_pointcloud_to_array(self, pointcloud_msg):\n        \"\"\"Convert PointCloud2 message to numpy array\"\"\"\n        # In a real implementation, use libraries like sensor_msgs_py\n        # For simulation, return a dummy array\n        # This is a simplified version - real implementation would extract x, y, z coordinates\n\n        # Simulate point cloud data\n        num_points = 100\n        points = np.random.rand(num_points, 3) * 2  # Random points in 2x2x2 cube\n        points[:, 2] += 0.5  # Shift to positive Z\n\n        return points\n\n    def calculate_surface_roughness(self, points):\n        \"\"\"Calculate surface roughness from point cloud\"\"\"\n        if len(points) < 3:\n            return 0.0\n\n        # Calculate local roughness by fitting planes to small neighborhoods\n        roughness_samples = []\n\n        # Sample neighborhoods\n        sample_size = min(10, len(points))\n        for i in range(0, len(points), max(1, len(points) // sample_size)):\n            neighborhood = points[i:i+10] if i+10 < len(points) else points[i:]\n\n            if len(neighborhood) >= 3:\n                # Fit a plane to the neighborhood\n                plane_params = self.fit_plane(neighborhood)\n\n                # Calculate deviations from the plane\n                distances = [self.point_to_plane_distance(point, plane_params)\n                           for point in neighborhood]\n\n                if distances:\n                    roughness_samples.append(np.std(distances))\n\n        return np.mean(roughness_samples) if roughness_samples else 0.0\n\n    def fit_plane(self, points):\n        \"\"\"Fit a plane to a set of 3D points using SVD\"\"\"\n        if len(points) < 3:\n            return [0, 0, 1, 0]  # Default: horizontal plane\n\n        # Center the points\n        centroid = np.mean(points, axis=0)\n        centered_points = points - centroid\n\n        # Calculate covariance matrix\n        cov_matrix = np.cov(centered_points.T)\n\n        # Find the normal vector (eigenvector corresponding to smallest eigenvalue)\n        eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)\n        normal = eigenvectors[:, 0]  # Smallest eigenvalue's eigenvector\n\n        # Calculate d parameter: ax + by + cz + d = 0\n        d = -np.dot(normal, centroid)\n\n        return [normal[0], normal[1], normal[2], d]\n\n    def point_to_plane_distance(self, point, plane_params):\n        \"\"\"Calculate distance from point to plane\"\"\"\n        a, b, c, d = plane_params\n        x, y, z = point\n        return abs(a*x + b*y + c*z + d) / math.sqrt(a*a + b*b + c*c)\n\n    def calculate_surface_slope(self, points):\n        \"\"\"Calculate average surface slope\"\"\"\n        if len(points) < 3:\n            return 0.0\n\n        # Fit a plane to all points\n        plane_params = self.fit_plane(points)\n\n        # The slope is related to the angle of the normal vector with the z-axis\n        a, b, c, d = plane_params\n        normal = np.array([a, b, c])\n\n        # Calculate angle with z-axis (0, 0, 1)\n        z_axis = np.array([0, 0, 1])\n        cos_angle = np.dot(normal, z_axis) / (np.linalg.norm(normal) * np.linalg.norm(z_axis))\n\n        # Convert to slope angle\n        slope_angle = np.arccos(np.clip(cos_angle, -1, 1))\n\n        return slope_angle\n\n    def classify_terrain(self, roughness, slope):\n        \"\"\"Classify terrain based on roughness and slope\"\"\"\n        best_match = 'flat'\n        best_confidence = 0.0\n\n        for terrain_type, params in self.terrain_types.items():\n            # Calculate similarity score (simplified)\n            roughness_score = 1.0 - min(abs(roughness - params['roughness_threshold']), 1.0)\n            slope_score = 1.0 - min(abs(slope - params['slope_threshold']), 1.0)\n\n            # Combine scores\n            combined_score = (roughness_score + slope_score) / 2.0\n\n            if combined_score > best_confidence:\n                best_confidence = combined_score\n                best_match = terrain_type\n\n        return best_match, best_confidence\n\n    def extract_texture_features(self, image):\n        \"\"\"Extract texture features from camera image\"\"\"\n        # Convert to grayscale\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n        # Calculate local binary pattern (simplified)\n        # In practice, you might use more sophisticated features\n        features = {\n            'mean_intensity': np.mean(gray),\n            'std_intensity': np.std(gray),\n            'edges': cv2.Laplacian(gray, cv2.CV_64F).var()\n        }\n\n        return features\n\n    def publish_adapted_parameters(self, terrain_type):\n        \"\"\"Publish adapted footstep parameters based on terrain\"\"\"\n        params = self.terrain_types[terrain_type]\n\n        # Create parameter string\n        param_str = f\"step_height:{params['step_height']},slope_thresh:{params['slope_threshold']},roughness_thresh:{params['roughness_threshold']}\"\n\n        param_msg = String()\n        param_msg.data = param_str\n        self.footstep_params_pub.publish(param_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TerrainAdaptationNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"balance-aware-path-planning",children:"Balance-Aware Path Planning"}),"\n",(0,a.jsx)(n.h3,{id:"center-of-mass-optimization",children:"Center of Mass Optimization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom nav_msgs.msg import Path\nfrom std_msgs.msg import Float32\nimport numpy as np\nimport math\n\nclass BalanceAwarePlanner(Node):\n    def __init__(self):\n        super().__init__(\'balance_aware_planner\')\n\n        # Subscribe to robot state and path\n        self.path_sub = self.create_subscription(\n            Path,\n            \'/plan\',\n            self.path_callback,\n            10\n        )\n\n        self.com_sub = self.create_subscription(\n            PoseStamped,\n            \'/center_of_mass\',\n            self.com_callback,\n            10\n        )\n\n        # Publishers\n        self.adjusted_path_pub = self.create_publisher(Path, \'/balance_aware_plan\', 10)\n        self.balance_score_pub = self.create_publisher(Float32, \'/balance_score\', 10)\n\n        # Robot parameters\n        self.robot_height = 0.8  # meters\n        self.foot_separation = 0.2  # meters\n        self.support_polygon_margin = 0.1  # meters\n\n        # Current state\n        self.original_path = None\n        self.current_com = None\n        self.balance_threshold = 0.8  # Minimum balance score\n\n        self.get_logger().info(\'Balance-Aware Planner initialized\')\n\n    def com_callback(self, msg):\n        """Update center of mass position"""\n        self.current_com = msg.pose.position\n\n    def path_callback(self, msg):\n        """Process path and adjust for balance"""\n        self.original_path = msg\n        self.adjust_path_for_balance()\n\n    def adjust_path_for_balance(self):\n        """Adjust path considering balance constraints"""\n        if self.original_path is None or self.current_com is None:\n            return\n\n        # Calculate balance-aware path\n        adjusted_path = self.calculate_balance_aware_path()\n\n        if adjusted_path:\n            # Publish adjusted path\n            self.adjusted_path_pub.publish(adjusted_path)\n\n            # Calculate and publish balance score\n            balance_score = self.calculate_balance_score(adjusted_path)\n            score_msg = Float32()\n            score_msg.data = balance_score\n            self.balance_score_pub.publish(score_msg)\n\n    def calculate_balance_aware_path(self):\n        """Calculate path that maintains balance"""\n        if not self.original_path.poses:\n            return None\n\n        adjusted_path = Path()\n        adjusted_path.header = self.original_path.header\n\n        for i, pose_stamped in enumerate(self.original_path.poses):\n            # Calculate required foot positions to maintain balance\n            adjusted_pose = self.adjust_pose_for_balance(pose_stamped, i)\n            adjusted_path.poses.append(adjusted_pose)\n\n        return adjusted_path\n\n    def adjust_pose_for_balance(self, original_pose, step_index):\n        """Adjust a single pose considering balance"""\n        # Calculate desired center of mass position for this step\n        desired_com_x = original_pose.pose.position.x\n        desired_com_y = original_pose.pose.position.y\n\n        # Get current center of mass\n        if self.current_com:\n            current_com_x = self.current_com.x\n            current_com_y = self.current_com.y\n        else:\n            current_com_x, current_com_y = 0, 0\n\n        # Calculate balance correction\n        correction_x = (desired_com_x - current_com_x) * 0.1  # Small correction factor\n        correction_y = (desired_com_y - current_com_y) * 0.1\n\n        # Apply correction to foot position\n        adjusted_pose = PoseStamped()\n        adjusted_pose.header = original_pose.header\n        adjusted_pose.pose.position.x = original_pose.pose.position.x + correction_x\n        adjusted_pose.pose.position.y = original_pose.pose.position.y + correction_y\n        adjusted_pose.pose.position.z = original_pose.pose.position.z\n        adjusted_pose.pose.orientation = original_pose.pose.orientation\n\n        return adjusted_pose\n\n    def calculate_balance_score(self, path):\n        """Calculate overall balance score for the path"""\n        if not path.poses or not self.current_com:\n            return 0.0\n\n        total_stability = 0.0\n        num_points = len(path.poses)\n\n        for i, pose_stamped in enumerate(path.poses):\n            # Calculate stability at this point\n            stability = self.calculate_point_stability(\n                pose_stamped.pose.position.x,\n                pose_stamped.pose.position.y,\n                self.current_com.x if self.current_com else 0,\n                self.current_com.y if self.current_com else 0\n            )\n            total_stability += stability\n\n        return total_stability / num_points if num_points > 0 else 0.0\n\n    def calculate_point_stability(self, foot_x, foot_y, com_x, com_y):\n        """Calculate stability of a foot placement relative to CoM"""\n        # Calculate distance from center of mass to foot position\n        com_to_foot_dist = math.sqrt((com_x - foot_x)**2 + (com_y - foot_y)**2)\n\n        # Calculate stability score (inverse relationship with distance)\n        # Normalized to 0-1 range\n        max_stable_distance = self.foot_separation / 2 + self.support_polygon_margin\n        stability = max(0, 1 - (com_to_foot_dist / max_stable_distance))\n\n        return stability\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = BalanceAwarePlanner()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"hands-on-lab-complete-humanoid-navigation-system",children:"Hands-on Lab: Complete Humanoid Navigation System"}),"\n",(0,a.jsx)(n.p,{children:"In this lab, you'll integrate all the components to create a complete humanoid navigation system."}),"\n",(0,a.jsx)(n.h3,{id:"step-1-create-the-main-navigation-node",children:"Step 1: Create the Main Navigation Node"}),"\n",(0,a.jsxs)(n.p,{children:["Create ",(0,a.jsx)(n.code,{children:"humanoid_navigation_system.py"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan, PointCloud2, Imu\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Path, Odometry\nfrom std_msgs.msg import Bool, String\nfrom visualization_msgs.msg import MarkerArray\nimport numpy as np\nimport math\nfrom collections import deque\nimport threading\n\nclass HumanoidNavigationSystem(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_navigation_system\')\n\n        # Subscribe to all sensors\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            \'/scan\',\n            self.scan_callback,\n            10\n        )\n\n        self.pointcloud_sub = self.create_subscription(\n            PointCloud2,\n            \'/points2\',\n            self.pointcloud_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            \'/imu/data\',\n            self.imu_callback,\n            10\n        )\n\n        self.odom_sub = self.create_subscription(\n            Odometry,\n            \'/odom\',\n            self.odom_callback,\n            10\n        )\n\n        self.goal_sub = self.create_subscription(\n            PoseStamped,\n            \'/goal_pose\',\n            self.goal_callback,\n            10\n        )\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.status_pub = self.create_publisher(Bool, \'/navigation_status\', 10)\n        self.path_pub = self.create_publisher(Path, \'/humanoid_path\', 10)\n        self.marker_pub = self.create_publisher(MarkerArray, \'/navigation_markers\', 10)\n\n        # Navigation state\n        self.current_goal = None\n        self.robot_pose = None\n        self.imu_data = None\n        self.navigation_active = False\n        self.emergency_stop = False\n\n        # Robot parameters\n        self.robot_params = {\n            \'step_length_max\': 0.3,      # meters\n            \'step_width_max\': 0.2,       # meters\n            \'step_height_max\': 0.1,      # meters\n            \'turn_radius_min\': 0.5,      # meters\n            \'max_linear_speed\': 0.3,     # m/s\n            \'max_angular_speed\': 0.5,    # rad/s\n            \'com_height\': 0.8,           # center of mass height\n            \'foot_size\': 0.15            # foot size for support polygon\n        }\n\n        # Navigation buffers\n        self.path_buffer = deque(maxlen=100)\n        self.trajectory_buffer = deque(maxlen=50)\n\n        # Threading lock\n        self.nav_lock = threading.Lock()\n\n        self.get_logger().info(\'Humanoid Navigation System initialized\')\n\n    def goal_callback(self, msg):\n        """Handle navigation goal"""\n        with self.nav_lock:\n            self.current_goal = msg\n            self.navigation_active = True\n\n            # Publish navigation active status\n            status_msg = Bool()\n            status_msg.data = True\n            self.status_pub.publish(status_msg)\n\n            self.get_logger().info(f\'Navigation goal received: ({msg.pose.position.x:.2f}, {msg.pose.position.y:.2f})\')\n\n    def odom_callback(self, msg):\n        """Update robot pose from odometry"""\n        with self.nav_lock:\n            self.robot_pose = msg.pose.pose\n\n    def imu_callback(self, msg):\n        """Process IMU data for balance"""\n        with self.nav_lock:\n            self.imu_data = msg\n\n            # Check for dangerous tilt angles that might require emergency stop\n            roll, pitch, yaw = self.quaternion_to_euler(\n                msg.orientation.x,\n                msg.orientation.y,\n                msg.orientation.z,\n                msg.orientation.w\n            )\n\n            # Emergency stop if tilt is too high\n            max_tilt = 0.5  # 30 degrees in radians\n            if abs(roll) > max_tilt or abs(pitch) > max_tilt:\n                self.emergency_stop = True\n                self.get_logger().warn(f\'Emergency stop triggered! Roll: {roll:.2f}, Pitch: {pitch:.2f}\')\n\n    def scan_callback(self, msg):\n        """Process laser scan for obstacle detection"""\n        with self.nav_lock:\n            if not self.navigation_active or self.emergency_stop:\n                return\n\n            # Process scan data for navigation\n            self.process_scan_for_navigation(msg)\n\n    def pointcloud_callback(self, msg):\n        """Process point cloud for terrain analysis"""\n        with self.nav_lock:\n            # Process point cloud for terrain classification\n            # This would integrate with the terrain adaptation system\n            pass\n\n    def process_scan_for_navigation(self, scan_msg):\n        """Process scan data for navigation decisions"""\n        # Convert scan to usable format\n        angles = np.array([scan_msg.angle_min + i * scan_msg.angle_increment\n                          for i in range(len(scan_msg.ranges))])\n        ranges = np.array(scan_msg.ranges)\n\n        # Filter valid ranges\n        valid_mask = (ranges >= scan_msg.range_min) & (ranges <= scan_msg.range_max) & \\\n                    (~np.isnan(ranges)) & (~np.isinf(ranges))\n        valid_ranges = ranges[valid_mask]\n        valid_angles = angles[valid_mask]\n\n        # Check for obstacles in path\n        obstacle_detected = self.check_path_obstacles(valid_ranges, valid_angles)\n\n        if obstacle_detected:\n            # Generate avoidance command\n            cmd_vel = self.generate_avoidance_command(valid_ranges, valid_angles)\n        else:\n            # Follow planned path\n            cmd_vel = self.follow_planned_path()\n\n        # Publish velocity command\n        self.cmd_vel_pub.publish(cmd_vel)\n\n    def check_path_obstacles(self, ranges, angles):\n        """Check if obstacles are blocking the planned path"""\n        # Define sectors to check (front, front-left, front-right)\n        front_mask = (np.abs(angles) < 0.5)  # Front 60 degrees\n        front_left_mask = (angles > 0.5) & (angles < 1.0)  # Front-left\n        front_right_mask = (angles < -0.5) & (angles > -1.0)  # Front-right\n\n        # Check minimum distances in each sector\n        min_front = np.min(ranges[front_mask]) if np.any(front_mask) else float(\'inf\')\n        min_front_left = np.min(ranges[front_left_mask]) if np.any(front_left_mask) else float(\'inf\')\n        min_front_right = np.min(ranges[front_right_mask]) if np.any(front_right_mask) else float(\'inf\')\n\n        # Define safety distances\n        safety_distance = 0.5  # meters\n\n        return (min_front < safety_distance or\n                min_front_left < safety_distance or\n                min_front_right < safety_distance)\n\n    def generate_avoidance_command(self, ranges, angles):\n        """Generate command to avoid detected obstacles"""\n        cmd_vel = Twist()\n\n        # Find the direction with maximum clear space\n        sector_size = 0.3  # radians per sector\n        num_sectors = int(2 * math.pi / sector_size)\n\n        sector_distances = []\n        for i in range(num_sectors):\n            sector_start = i * sector_size - math.pi\n            sector_end = (i + 1) * sector_size - math.pi\n\n            sector_mask = (angles >= sector_start) & (angles < sector_end)\n            if np.any(sector_mask):\n                sector_dist = np.mean(ranges[sector_mask])\n            else:\n                sector_dist = 0\n\n            sector_distances.append(sector_dist)\n\n        # Find the sector with maximum distance\n        best_sector = np.argmax(sector_distances)\n        best_angle = best_sector * sector_size - math.pi + sector_size / 2\n\n        # Generate command based on best direction\n        cmd_vel.linear.x = self.robot_params[\'max_linear_speed\'] * 0.3  # Slow down\n        cmd_vel.angular.z = best_angle * 1.0  # Turn toward clear direction\n\n        # Limit angular velocity\n        cmd_vel.angular.z = max(-self.robot_params[\'max_angular_speed\'],\n                               min(self.robot_params[\'max_angular_speed\'], cmd_vel.angular.z))\n\n        return cmd_vel\n\n    def follow_planned_path(self):\n        """Follow the planned navigation path"""\n        cmd_vel = Twist()\n\n        if self.current_goal is None or self.robot_pose is None:\n            return cmd_vel\n\n        # Calculate direction to goal\n        goal_x = self.current_goal.pose.position.x\n        goal_y = self.current_goal.pose.position.y\n        robot_x = self.robot_pose.position.x\n        robot_y = self.robot_pose.position.y\n\n        dx = goal_x - robot_x\n        dy = goal_y - robot_y\n        distance_to_goal = math.sqrt(dx**2 + dy**2)\n\n        # Calculate desired direction\n        desired_angle = math.atan2(dy, dx)\n\n        # Simple proportional controller\n        cmd_vel.linear.x = min(self.robot_params[\'max_linear_speed\'],\n                              max(0.1, distance_to_goal * 0.5))\n        cmd_vel.angular.z = desired_angle * 1.5  # Proportional gain\n\n        # Limit angular velocity\n        cmd_vel.angular.z = max(-self.robot_params[\'max_angular_speed\'],\n                               min(self.robot_params[\'max_angular_speed\'], cmd_vel.angular.z))\n\n        # Check if goal is reached\n        if distance_to_goal < 0.3:  # 30 cm tolerance\n            cmd_vel.linear.x = 0.0\n            cmd_vel.angular.z = 0.0\n            self.navigation_active = False\n\n            # Publish completion status\n            status_msg = Bool()\n            status_msg.data = False\n            self.status_pub.publish(status_msg)\n\n            self.get_logger().info(\'Navigation goal reached!\')\n\n        return cmd_vel\n\n    def quaternion_to_euler(self, x, y, z, w):\n        """Convert quaternion to Euler angles"""\n        # Roll (x-axis rotation)\n        sinr_cosp = 2 * (w * x + y * z)\n        cosr_cosp = 1 - 2 * (x * x + y * y)\n        roll = math.atan2(sinr_cosp, cosr_cosp)\n\n        # Pitch (y-axis rotation)\n        sinp = 2 * (w * y - z * x)\n        if abs(sinp) >= 1:\n            pitch = math.copysign(math.pi / 2, sinp)  # Use 90 degrees if out of range\n        else:\n            pitch = math.asin(sinp)\n\n        # Yaw (z-axis rotation)\n        siny_cosp = 2 * (w * z + x * y)\n        cosy_cosp = 1 - 2 * (y * y + z * z)\n        yaw = math.atan2(siny_cosp, cosy_cosp)\n\n        return roll, pitch, yaw\n\n    def publish_navigation_markers(self):\n        """Publish visualization markers"""\n        # Implementation would create markers for path, obstacles, etc.\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidNavigationSystem()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        print("Shutting down humanoid navigation system...")\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"step-2-test-the-navigation-system",children:"Step 2: Test the Navigation System"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Run the complete navigation system:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"python3 humanoid_navigation_system.py\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:"Send navigation goals using RViz or command line:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Send a goal using command line\nros2 action send_goal /navigate_to_pose geometry_msgs/PoseStamped \"{header: {frame_id: 'map'}, pose: {position: {x: 5.0, y: 5.0, z: 0.0}, orientation: {w: 1.0}}}\"\n"})}),"\n",(0,a.jsx)(n.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"adaptive-parameter-tuning",children:"Adaptive Parameter Tuning"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float32\nfrom geometry_msgs.msg import Twist\nimport numpy as np\n\nclass AdaptiveParameterTuner(Node):\n    def __init__(self):\n        super().__init__('adaptive_parameter_tuner')\n\n        # Subscribe to performance metrics\n        self.balance_sub = self.create_subscription(\n            Float32,\n            '/balance_score',\n            self.balance_callback,\n            10\n        )\n\n        self.stability_sub = self.create_subscription(\n            Float32,\n            '/stability_score',\n            self.stability_callback,\n            10\n        )\n\n        # Publisher for parameter updates\n        self.param_pub = self.create_publisher(Twist, '/parameter_updates', 10)\n\n        # Performance tracking\n        self.balance_history = []\n        self.stability_history = []\n        self.max_history = 50\n\n        # Current parameters\n        self.current_speed_factor = 1.0\n        self.current_turn_factor = 1.0\n\n        self.get_logger().info('Adaptive Parameter Tuner initialized')\n\n    def balance_callback(self, msg):\n        \"\"\"Process balance score and adjust parameters\"\"\"\n        self.balance_history.append(msg.data)\n        if len(self.balance_history) > self.max_history:\n            self.balance_history.pop(0)\n\n        # Adjust parameters based on balance\n        avg_balance = np.mean(self.balance_history) if self.balance_history else 0.5\n\n        if avg_balance < 0.7:  # Poor balance\n            self.current_speed_factor = max(0.5, self.current_speed_factor * 0.95)\n            self.current_turn_factor = max(0.7, self.current_turn_factor * 0.98)\n        elif avg_balance > 0.9:  # Good balance\n            self.current_speed_factor = min(1.2, self.current_speed_factor * 1.01)\n\n    def stability_callback(self, msg):\n        \"\"\"Process stability score\"\"\"\n        self.stability_history.append(msg.data)\n        if len(self.stability_history) > self.max_history:\n            self.stability_history.pop(0)\n\n    def get_adaptive_parameters(self):\n        \"\"\"Get current adaptive parameters\"\"\"\n        params = {\n            'speed_factor': self.current_speed_factor,\n            'turn_factor': self.current_turn_factor,\n            'balance_score': np.mean(self.balance_history) if self.balance_history else 0.5,\n            'stability_score': np.mean(self.stability_history) if self.stability_history else 0.5\n        }\n        return params\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = AdaptiveParameterTuner()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Stability First"}),": Always prioritize robot stability over speed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gradual Changes"}),": Make smooth transitions between different walking patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sensor Fusion"}),": Combine multiple sensor inputs for robust terrain assessment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fallback Behaviors"}),": Implement safe stopping procedures for unexpected situations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameter Adaptation"}),": Adjust walking parameters based on terrain and performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testing"}),": Extensively test on various terrains before deployment"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"After completing this chapter, you'll be ready to learn about perception systems for humanoid robots in Chapter 6."})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(6540);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);