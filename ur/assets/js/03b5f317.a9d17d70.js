"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[834],{317:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2/chapter-2/gazebo-physics","title":"Gazebo Physics Simulation","description":"This chapter covers the fundamentals of physics simulation in Gazebo, including how to create realistic environments for humanoid robots with proper physics properties.","source":"@site/docs/module-2/chapter-2/gazebo-physics.md","sourceDirName":"module-2/chapter-2","slug":"/module-2/chapter-2/gazebo-physics","permalink":"/ai-robo-learning/ur/docs/module-2/chapter-2/gazebo-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/madnan-github/ai-robo-learning/docs/module-2/chapter-2/gazebo-physics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Gazebo Physics Simulation"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Fundamentals","permalink":"/ai-robo-learning/ur/docs/module-2/chapter-1/ros2-fundamentals"},"next":{"title":"Creating Robot Models in Gazebo","permalink":"/ai-robo-learning/ur/docs/module-2/chapter-3/robot-models-gazebo"}}');var a=i(4848),r=i(8453);const l={sidebar_position:2,title:"Gazebo Physics Simulation"},o="Gazebo Physics Simulation",t={},c=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Understanding Gazebo Physics",id:"understanding-gazebo-physics",level:2},{value:"Physics Simulation Concepts",id:"physics-simulation-concepts",level:3},{value:"Setting Up a Basic Gazebo World",id:"setting-up-a-basic-gazebo-world",level:2},{value:"Creating a World File",id:"creating-a-world-file",level:3},{value:"Physics Engine Parameters",id:"physics-engine-parameters",level:3},{value:"Creating Physics Models",id:"creating-physics-models",level:2},{value:"Model with Physics Properties",id:"model-with-physics-properties",level:3},{value:"Physics Properties in Detail",id:"physics-properties-in-detail",level:2},{value:"Mass and Inertia",id:"mass-and-inertia",level:3},{value:"Friction Properties",id:"friction-properties",level:3},{value:"Damping and Compliance",id:"damping-and-compliance",level:3},{value:"Humanoid Robot Physics Configuration",id:"humanoid-robot-physics-configuration",level:2},{value:"Joint Dynamics",id:"joint-dynamics",level:3},{value:"Balance and Stability",id:"balance-and-stability",level:3},{value:"Hands-on Lab: Physics Playground",id:"hands-on-lab-physics-playground",level:2},{value:"Step 1: Create a Physics World",id:"step-1-create-a-physics-world",level:3},{value:"Step 2: Launch the Simulation",id:"step-2-launch-the-simulation",level:3},{value:"Debugging Physics Simulation",id:"debugging-physics-simulation",level:2},{value:"Common Physics Issues",id:"common-physics-issues",level:3},{value:"Physics Debugging Tools",id:"physics-debugging-tools",level:3},{value:"Advanced Physics Features",id:"advanced-physics-features",level:2},{value:"Buoyancy Simulation",id:"buoyancy-simulation",level:3},{value:"Wind Simulation",id:"wind-simulation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"gazebo-physics-simulation",children:"Gazebo Physics Simulation"})}),"\n",(0,a.jsx)(e.p,{children:"This chapter covers the fundamentals of physics simulation in Gazebo, including how to create realistic environments for humanoid robots with proper physics properties."}),"\n",(0,a.jsx)(e.h2,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,a.jsx)(e.p,{children:"In this chapter, you'll explore:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Gazebo simulation environment setup"}),"\n",(0,a.jsx)(e.li,{children:"Physics engine concepts and parameters"}),"\n",(0,a.jsx)(e.li,{children:"Creating realistic physics environments"}),"\n",(0,a.jsx)(e.li,{children:"Configuring gravity, friction, and damping"}),"\n",(0,a.jsx)(e.li,{children:"Debugging physics simulation issues"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Completion of Module 1"}),"\n",(0,a.jsx)(e.li,{children:"ROS 2 Humble installed"}),"\n",(0,a.jsx)(e.li,{children:"Gazebo Harmonic installed"}),"\n",(0,a.jsx)(e.li,{children:"Basic understanding of physics concepts"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"understanding-gazebo-physics",children:"Understanding Gazebo Physics"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo uses physics engines to simulate realistic interactions between objects. The main physics engines supported are:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),": Default engine, good for most applications"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bullet"}),": More robust for complex contact scenarios"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"DART"}),": Advanced dynamics and robotics toolkit"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"physics-simulation-concepts",children:"Physics Simulation Concepts"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo simulates physics through:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collision Detection"}),": Determining when objects intersect"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Contact Processing"}),": Calculating forces when objects touch"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamics"}),": Computing motion based on forces and torques"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Constraints"}),": Limiting motion through joints"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"setting-up-a-basic-gazebo-world",children:"Setting Up a Basic Gazebo World"}),"\n",(0,a.jsx)(e.h3,{id:"creating-a-world-file",children:"Creating a World File"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo world files are XML files that define the simulation environment:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_world">\n    \x3c!-- Include a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include a sky --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Physics parameters --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Your robot will be spawned here --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"physics-engine-parameters",children:"Physics Engine Parameters"}),"\n",(0,a.jsx)(e.p,{children:"Key physics parameters that affect simulation quality:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"max_step_size"}),": Maximum time step for physics updates (smaller = more accurate but slower)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"real_time_factor"}),": Target simulation speed relative to real time"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"real_time_update_rate"}),": Updates per second"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"gravity"}),": Gravitational acceleration vector"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"creating-physics-models",children:"Creating Physics Models"}),"\n",(0,a.jsx)(e.h3,{id:"model-with-physics-properties",children:"Model with Physics Properties"}),"\n",(0,a.jsx)(e.p,{children:"Here's an example of a simple box with physics properties:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <model name="physics_box">\n    <pose>0 0 1 0 0 0</pose>\n\n    \x3c!-- Link definition --\x3e\n    <link name="box_link">\n      \x3c!-- Visual properties --\x3e\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.2 0.2 0.2</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.8 0.2 0.2 1</ambient>\n          <diffuse>0.8 0.2 0.2 1</diffuse>\n        </material>\n      </visual>\n\n      \x3c!-- Collision properties --\x3e\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.2 0.2 0.2</size>\n          </box>\n        </geometry>\n      </collision>\n\n      \x3c!-- Inertial properties --\x3e\n      <inertial>\n        <mass>1.0</mass>\n        <inertia>\n          <ixx>0.0083</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.0083</iyy>\n          <iyz>0</iyz>\n          <izz>0.0083</izz>\n        </inertia>\n      </inertial>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"physics-properties-in-detail",children:"Physics Properties in Detail"}),"\n",(0,a.jsx)(e.h3,{id:"mass-and-inertia",children:"Mass and Inertia"}),"\n",(0,a.jsx)(e.p,{children:"For a box with mass m and dimensions (x, y, z), the inertia values are:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Ixx = m * (y\xb2 + z\xb2) / 12"}),"\n",(0,a.jsx)(e.li,{children:"Iyy = m * (x\xb2 + z\xb2) / 12"}),"\n",(0,a.jsx)(e.li,{children:"Izz = m * (x\xb2 + y\xb2) / 12"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:"<inertial>\n  <mass>2.0</mass>\n  <inertia>\n    <ixx>0.0667</ixx>  \x3c!-- 2.0 * (0.2\xb2 + 0.2\xb2) / 12 --\x3e\n    <iyy>0.0667</iyy>  \x3c!-- 2.0 * (0.2\xb2 + 0.2\xb2) / 12 --\x3e\n    <izz>0.0667</izz>  \x3c!-- 2.0 * (0.2\xb2 + 0.2\xb2) / 12 --\x3e\n  </inertia>\n</inertial>\n"})}),"\n",(0,a.jsx)(e.h3,{id:"friction-properties",children:"Friction Properties"}),"\n",(0,a.jsx)(e.p,{children:"Friction affects how objects slide against each other:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<collision name="collision">\n  <geometry>\n    <box><size>0.2 0.2 0.2</size></box>\n  </geometry>\n  <surface>\n    <friction>\n      <ode>\n        <mu>1.0</mu>      \x3c!-- Static friction coefficient --\x3e\n        <mu2>1.0</mu2>    \x3c!-- Secondary friction coefficient --\x3e\n        <fdir1>0 0 1</fdir1>  \x3c!-- Friction direction --\x3e\n      </ode>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"damping-and-compliance",children:"Damping and Compliance"}),"\n",(0,a.jsx)(e.p,{children:"Damping reduces oscillations and makes simulation more stable:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<collision name="collision">\n  <geometry>\n    <box><size>0.2 0.2 0.2</size></box>\n  </geometry>\n  <surface>\n    <bounce>\n      <restitution_coefficient>0.2</restitution_coefficient>\n      <threshold>100000</threshold>\n    </bounce>\n    <contact>\n      <ode>\n        <soft_cfm>0.001</soft_cfm>\n        <soft_erp>0.2</soft_erp>\n        <kp>10000000</kp>\n        <kd>1</kd>\n      </ode>\n    </contact>\n    <friction>\n      <ode>\n        <mu>1.0</mu>\n        <mu2>1.0</mu2>\n      </ode>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"humanoid-robot-physics-configuration",children:"Humanoid Robot Physics Configuration"}),"\n",(0,a.jsx)(e.p,{children:"For humanoid robots, special attention is needed for:"}),"\n",(0,a.jsx)(e.h3,{id:"joint-dynamics",children:"Joint Dynamics"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<joint name="knee_joint" type="revolute">\n  <parent>thigh_link</parent>\n  <child>shin_link</child>\n  <axis>\n    <xyz>0 1 0</xyz>\n    <limit>\n      <lower>0</lower>\n      <upper>1.57</upper>\n      <effort>100</effort>\n      <velocity>1</velocity>\n    </limit>\n    \x3c!-- Joint dynamics --\x3e\n    <dynamics>\n      <damping>0.1</damping>\n      <friction>0.05</friction>\n    </dynamics>\n  </axis>\n</joint>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"balance-and-stability",children:"Balance and Stability"}),"\n",(0,a.jsx)(e.p,{children:"For humanoid robots to maintain balance:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Torso with appropriate mass distribution --\x3e\n<link name="torso">\n  <inertial>\n    <mass>10.0</mass>\n    <origin xyz="0 0 0.2"/>\n    <inertia>\n      <ixx>0.5</ixx>\n      <iyy>0.3</iyy>\n      <izz>0.4</izz>\n    </inertia>\n  </inertial>\n</link>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"hands-on-lab-physics-playground",children:"Hands-on Lab: Physics Playground"}),"\n",(0,a.jsx)(e.p,{children:"In this lab, you'll create a physics simulation with different objects to understand how physics properties affect behavior."}),"\n",(0,a.jsx)(e.h3,{id:"step-1-create-a-physics-world",children:"Step 1: Create a Physics World"}),"\n",(0,a.jsxs)(e.p,{children:["Create ",(0,a.jsx)(e.code,{children:"physics_playground.world"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="physics_playground">\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Physics configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.000001</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Box with high friction --\x3e\n    <model name="high_friction_box">\n      <pose>0 1 0.2 0 0 0</pose>\n      <link name="link">\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.0083</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.0083</iyy>\n            <iyz>0</iyz>\n            <izz>0.0083</izz>\n          </inertia>\n        </inertial>\n        <visual name="visual">\n          <geometry>\n            <box><size>0.2 0.2 0.2</size></box>\n          </geometry>\n          <material>\n            <ambient>1 0 0 1</ambient>\n            <diffuse>1 0 0 1</diffuse>\n          </material>\n        </visual>\n        <collision name="collision">\n          <geometry>\n            <box><size>0.2 0.2 0.2</size></box>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>10.0</mu>\n                <mu2>10.0</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n      </link>\n    </model>\n\n    \x3c!-- Sphere with low friction --\x3e\n    <model name="low_friction_sphere">\n      <pose>0 -1 0.2 0 0 0</pose>\n      <link name="link">\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.004</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.004</iyy>\n            <iyz>0</iyz>\n            <izz>0.004</izz>\n          </inertia>\n        </inertial>\n        <visual name="visual">\n          <geometry>\n            <sphere><radius>0.1</radius></sphere>\n          </geometry>\n          <material>\n            <ambient>0 1 0 1</ambient>\n            <diffuse>0 1 0 1</diffuse>\n          </material>\n        </visual>\n        <collision name="collision">\n          <geometry>\n            <sphere><radius>0.1</radius></sphere>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.1</mu>\n                <mu2>0.1</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n      </link>\n    </model>\n\n    \x3c!-- Inclined plane --\x3e\n    <model name="inclined_plane">\n      <pose>2 0 1 0 0.3 0</pose>\n      <link name="link">\n        <inertial>\n          <mass>100.0</mass>\n          <inertia>\n            <ixx>100</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>100</iyy>\n            <iyz>0</iyz>\n            <izz>100</izz>\n          </inertia>\n        </inertial>\n        <visual name="visual">\n          <geometry>\n            <box><size>2 0.1 1</size></box>\n          </geometry>\n          <material>\n            <ambient>0.5 0.5 0.5 1</ambient>\n            <diffuse>0.5 0.5 0.5 1</diffuse>\n          </material>\n        </visual>\n        <collision name="collision">\n          <geometry>\n            <box><size>2 0.1 1</size></box>\n          </geometry>\n        </collision>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"step-2-launch-the-simulation",children:"Step 2: Launch the Simulation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Launch Gazebo with your world\ngz sim physics_playground.world\n"})}),"\n",(0,a.jsx)(e.h2,{id:"debugging-physics-simulation",children:"Debugging Physics Simulation"}),"\n",(0,a.jsx)(e.h3,{id:"common-physics-issues",children:"Common Physics Issues"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Objects falling through surfaces"}),": Check collision properties and world boundaries"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Unstable simulation"}),": Reduce max_step_size or adjust solver parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Robot falling over"}),": Check mass distribution and joint limits"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Jittery movement"}),": Adjust damping and friction parameters"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"physics-debugging-tools",children:"Physics Debugging Tools"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Launch Gazebo with verbose output\ngz sim -v 4 physics_playground.world\n\n# Use Gazebo GUI to inspect physics properties\n# View -> Transparent\n# View -> Wireframe\n# View -> Contacts\n"})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-physics-features",children:"Advanced Physics Features"}),"\n",(0,a.jsx)(e.h3,{id:"buoyancy-simulation",children:"Buoyancy Simulation"}),"\n",(0,a.jsx)(e.p,{children:"For underwater robots:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<plugin filename="gz-sim-buoyancy-system" name="gz::sim::systems::Buoyancy">\n  <link name="robot_base">0.1 0.1 0.2</link>\n</plugin>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"wind-simulation",children:"Wind Simulation"}),"\n",(0,a.jsx)(e.p,{children:"For aerial or outdoor robots:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml>",children:'<world name="windy_world">\n  <physics type="ode">\n    \x3c!-- Physics settings --\x3e\n  </physics>\n\n  <model name="wind_generator">\n    <static>true</static>\n    <link name="link">\n      <visual name="visual">\n        <geometry>\n          <box><size>0.1 0.1 0.1</size></box>\n        </geometry>\n      </visual>\n    </link>\n  </model>\n\n  <wind>\n    <linear_velocity>2 0 0</linear_velocity>\n    <factor>1.0</factor>\n  </wind>\n</world>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Start Simple"}),": Begin with basic shapes and gradually add complexity"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Tune Parameters"}),": Adjust physics parameters based on simulation behavior"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Validate Mass"}),": Ensure mass properties match real-world values"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Check Inertia"}),": Use proper inertia calculations for stable simulation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Test Stability"}),": Run simulations for extended periods to check for drift"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance Performance"}),": Find the right balance between accuracy and speed"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(e.p,{children:"After completing this chapter, you'll be ready to learn about creating robot models in Gazebo with proper simulation properties in Chapter 3."})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>o});var s=i(6540);const a={},r=s.createContext(a);function l(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:l(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);